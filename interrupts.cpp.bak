/**
 * @file interrupts.cpp
 * @author
 * Minimal working simulator for Part 3 (with FORK/EXEC recursion)
 */

#include <interrupts.hpp>
#include <tuple>
#include <vector>
#include <string>
#include <fstream>
#include <sstream>
#include <iostream>

// --------- small helper to log system status snapshots ----------
static inline void append_system_status(std::string& sys,
                                        int t,
                                        const PCB& current,
                                        const std::vector<PCB>& wait_queue) {
    std::ostringstream oss;
    oss << "[t=" << t << "] PID=" << current.PID
        << " part=" << current.partition_number
        << " prog=" << current.program_name << "\n";
    // memory[] comes from interrupts.hpp
    oss << "Mem: ";
    for (int i = 0; i < 6; ++i) {
        oss << "(p" << memory[i].partition_number << ":" << memory[i].code << ") ";
    }
    oss << "\nWaitQ: ";
    for (const auto& p : wait_queue) oss << p.PID << " ";
    oss << "\n";
    sys += oss.str();
}

// ----------------------------------------------------------------
// Core simulator
// ----------------------------------------------------------------
std::tuple<std::string, std::string, int>
simulate_trace(std::vector<std::string> trace_file,
               int start_time,
               std::vector<std::string> vectors,
               std::vector<int> delays,
               std::vector<external_file> external_files,
               PCB current,
               std::vector<PCB> wait_queue)
{
    std::string execution;       // timeline log
    std::string system_status;   // snapshots log
    int current_time = start_time;

    for (size_t i = 0; i < trace_file.size(); ++i) {
        auto line = trace_file[i];
        auto [activity, duration_or_intr, program_name] = parse_trace(line);

        if (activity == "CPU") {
            // CPU burst
            execution += std::to_string(current_time) + ", "
                       + std::to_string(duration_or_intr) + ", CPU Burst\n";
            current_time += duration_or_intr;
            append_system_status(system_status, current_time, current, wait_queue);
        }
        else if (activity == "SYSCALL") {
            // interrupt boilerplate
            auto [intr, t2] = intr_boilerplate(current_time, duration_or_intr, 10, vectors);
            execution   += intr;
            current_time = t2;

            // do the ISR (delay read from device table)
            execution += std::to_string(current_time) + ", "
                       + std::to_string(delays[duration_or_intr]) + ", SYSCALL ISR\n";
            current_time += delays[duration_or_intr];

            // IRET
            execution += std::to_string(current_time) + ", 1, IRET\n";
            current_time += 1;

            append_system_status(system_status, current_time, current, wait_queue);
        }
        else if (activity == "END_IO") {
            auto [intr, t2] = intr_boilerplate(current_time, duration_or_intr, 10, vectors);
            execution   += intr;
            current_time = t2;

            execution += std::to_string(current_time) + ", "
                       + std::to_string(delays[duration_or_intr]) + ", ENDIO ISR\n";
            current_time += delays[duration_or_intr];

            execution += std::to_string(current_time) + ", 1, IRET\n";
            current_time += 1;

            append_system_status(system_status, current_time, current, wait_queue);
        }
        else if (activity == "FORK") {
            // Enter FORK interrupt (we’ll use intr number 2 like in your template)
            auto [intr, t2] = intr_boilerplate(current_time, 2, 10, vectors);
            execution   += intr;
            current_time = t2;

            // ---------------- collect child trace + find where parent resumes ----------------
            std::vector<std::string> child_trace;
            bool skip = true;        // skipping lines not for child until IF_CHILD
            bool exec_seen = false;  // stop collecting at first EXEC in child
            int parent_index = static_cast<int>(i); // fallback

            for (size_t j = i; j < trace_file.size(); ++j) {
                auto [_act, _dur, _pn] = parse_trace(trace_file[j]);

                if (skip && _act == "IF_CHILD") {
                    skip = false;
                    continue;
                } else if (_act == "IF_PARENT") {
                    // mark where the parent block starts again
                    skip = true;
                    parent_index = static_cast<int>(j);
                    if (exec_seen) break; // we have child + first EXEC; stop here
                    continue;
                } else if (skip && _act == "ENDIF") {
                    skip = false;
                    continue;
                } else if (!skip && _act == "EXEC") {
                    // include the EXEC line in child trace and stop collecting
                    child_trace.push_back(trace_file[j]);
                    exec_seen = true;
                    // continue so the outer break happens at IF_PARENT
                }

                if (!skip) {
                    child_trace.push_back(trace_file[j]);
                }
            }

            // move outer loop index to where the parent should continue
            i = (parent_index > static_cast<int>(i)) ? parent_index : i;

            // ---------------- create child PCB and run it recursively ----------------
            PCB child(current.PID + 1, current.PID,
                      current.program_name + "_child",
                      /*size*/ 1,
                      /*partition*/ -1);

            execution += std::to_string(current_time) + ", 1, FORK: create child PID="
                       + std::to_string(child.PID) + "\n";
            current_time += 1;

            if (allocate_memory(&child)) {
                execution += std::to_string(current_time) + ", 1, child PID="
                           + std::to_string(child.PID)
                           + " allocated partition "
                           + std::to_string(child.partition_number) + "\n";
                current_time += 1;
            } else {
                execution += std::to_string(current_time) + ", 1, child PID="
                           + std::to_string(child.PID)
                           + " FAILED to allocate memory\n";
                current_time += 1;
            }

            auto [child_exec, child_sys, child_end_time] =
                simulate_trace(child_trace,
                               current_time,
                               vectors,
                               delays,
                               external_files,
                               child,
                               wait_queue);

            execution     += child_exec;
            system_status += child_sys;
            current_time   = child_end_time;

            if (child.partition_number != -1) {
                free_memory(&child);
                execution += std::to_string(current_time) + ", 1, child PID="
                           + std::to_string(child.PID)
                           + " freed partition and exited\n";
                current_time += 1;
            }

            append_system_status(system_status, current_time, current, wait_queue);
        }
        else if (activity == "EXEC") {
            // Enter EXEC interrupt (template uses intr number 3)
            auto [intr, t2] = intr_boilerplate(current_time, 3, 10, vectors);
            execution   += intr;
            current_time = t2;

            // Load external program image size from external_files list
            unsigned img_size = 1;
            for (const auto& f : external_files) {
                if (f.program_name == program_name) {
                    img_size = f.size;
                    break;
                }
            }

            // New PCB for exec image replaces current program (conceptually)
            PCB exec_pcb(current.PID, current.PPID, program_name, img_size, -1);

            execution += std::to_string(current_time) + ", 1, EXEC load image '"
                       + program_name + "'\n";
            current_time += 1;

            if (!allocate_memory(&exec_pcb)) {
                execution += std::to_string(current_time) + ", 1, EXEC failed: no memory\n";
                current_time += 1;
                // Return to parent timeline; no recursion possible
                break; // important: mirrors template’s “break after exec”
            } else {
                execution += std::to_string(current_time) + ", 1, EXEC image allocated partition "
                           + std::to_string(exec_pcb.partition_number) + "\n";
                current_time += 1;
            }

            // Load the external program’s trace (program_name + ".txt")
            std::ifstream exec_trace_file(program_name + std::string(".txt"));
            std::vector<std::string> exec_traces;
            if (exec_trace_file.is_open()) {
                std::string l;
                while (std::getline(exec_trace_file, l)) {
                    exec_traces.push_back(l);
                }
                exec_trace_file.close();
            } else {
                // If missing, just simulate a tiny CPU burst so output is still sane
                exec_traces.push_back("CPU,2");
            }

            auto [ex_exec, ex_sys, ex_end_time] =
                simulate_trace(exec_traces,
                               current_time,
                               vectors,
                               delays,
                               external_files,
                               exec_pcb,
                               wait_queue);

            execution     += ex_exec;
            system_status += ex_sys;
            current_time   = ex_end_time;

            // free exec image
            if (exec_pcb.partition_number != -1) {
                free_memory(&exec_pcb);
                execution += std::to_string(current_time) + ", 1, exec image freed\n";
                current_time += 1;
            }

            append_system_status(system_status, current_time, current, wait_queue);

            // IMPORTANT: the original template breaks after handling EXEC
            break;
        }
        // else: ignore unknown tags to be robust
    }

    return {execution, system_status, current_time};
}

// ----------------------------------------------------------------
// main
// ----------------------------------------------------------------
int main(int argc, char** argv) {
    // Parse CLI: trace file, vector table, device delays, external files
    auto [vectors, delays, external_files] = parse_args(argc, argv);

    // Just to show we parsed external files
    print_external_files(external_files);

    // Seed "init" PCB (partition assigned by allocate_memory)
    PCB current(0, -1, "init", 1, -1);
    if (!allocate_memory(&current)) {
        std::cerr << "ERROR! Memory allocation failed for init process!\n";
    }

    std::vector<PCB> wait_queue;

    // Read the top-level trace file into a vector of lines
    std::ifstream input_file(argv[1]);
    std::vector<std::string> trace_file;
    std::string line;
    while (std::getline(input_file, line)) {
        trace_file.push_back(line);
    }
    input_file.close();

    // Run simulation
    auto [execution, system_status, /*end_time*/ _] =
        simulate_trace(trace_file, 0, vectors, delays, external_files, current, wait_queue);

    // Write outputs to the assignment’s expected locations
    write_output(execution,      "output_files/execution.txt");
    write_output(system_status,  "output_files/system_status.txt");

    return 0;
}

